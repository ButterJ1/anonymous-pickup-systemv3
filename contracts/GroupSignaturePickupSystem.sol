// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IGroth16Verifier {
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[5] memory _publicSignals
    ) external view returns (bool);
}

/**
 * @title GroupSignaturePickupSystem
 * @dev Real anonymous package pickup system using ZK group signatures
 */
contract GroupSignaturePickupSystem {
    IGroth16Verifier public immutable verifier;
    
    struct Package {
        bytes32 packageId;
        uint256 buyerCommitment;     // From order placement
        uint256 sellerCommitment;    // Generated by seller/platform
        address storeAddress;        // Pickup location
        uint256 itemPrice;           // Item price in wei
        uint256 shippingFee;         // Shipping fee in wei
        uint256 minAgeRequired;      // 0 or 18
        bool isPickedUp;             // Pickup status
        uint256 registeredAt;        // Registration timestamp
        uint256 expiryTime;          // Pickup deadline
    }
    
    struct StoreCommitment {
        uint256 commitment;
        address storeAddress;
        bytes32 packageId;
        uint256 generatedAt;
        bool used;
    }
    
    // State mappings
    mapping(bytes32 => Package) public packages;
    mapping(uint256 => bool) public usedNullifiers;  // Prevent double pickup
    mapping(bytes32 => StoreCommitment) public storeCommitments;
    mapping(address => uint256) private storeSecrets;  // Store secrets for commitment generation
    mapping(address => bool) public authorizedStores;
    
    // Constants
    uint256 private constant PICKUP_VALIDITY_DAYS = 30;
    uint256 private constant MIN_PACKAGE_VALUE = 0.01 ether;
    
    // Events
    event StoreAuthorized(address indexed store);
    event StoreSecretSet(address indexed store);
    event PackageRegistered(
        bytes32 indexed packageId,
        uint256 buyerCommitment,
        uint256 sellerCommitment,
        address indexed store
    );
    event StoreCommitmentGenerated(
        bytes32 indexed packageId,
        uint256 storeCommitment,
        address indexed store
    );
    event PackagePickedUp(
        bytes32 indexed packageId,
        uint256 nullifier,
        uint256 groupSignature,
        address indexed store
    );
    
    // Custom errors
    error InvalidVerifier();
    error InvalidValue();           // ✅ ADDED - Missing error declaration
    error InvalidInput();           // ✅ ADDED - Missing error declaration
    error StoreNotAuthorized();
    error StoreAlreadyRegistered();
    error PackageAlreadyExists();
    error PackageNotFound();
    error PackageExpired();
    error PackageAlreadyPickedUp();
    error WrongStore();
    error InvalidAgeRequirement();
    error InsufficientValue();
    error StoreCommitmentExists();
    error StoreCommitmentNotFound();
    error NullifierAlreadyUsed();
    error InvalidProof();
    error PublicSignalMismatch();
    error AgeVerificationFailed();
    
    modifier onlyAuthorizedStore() {
        if (!authorizedStores[msg.sender]) revert StoreNotAuthorized();
        _;
    }
    
    constructor(address _verifier) {
        if (_verifier == address(0)) revert InvalidVerifier();
        verifier = IGroth16Verifier(_verifier);
    }
    
    /**
     * @dev Authorize a store for package pickup operations
     */
    function authorizeStore(address _store) external {
        // In production, this should have proper access control (onlyOwner, etc.)
        authorizedStores[_store] = true;
        emit StoreAuthorized(_store);
    }
    
    /**
     * @dev Set store secret for commitment generation
     */
    function setStoreSecret(uint256 _storeSecret) external onlyAuthorizedStore {
        if (storeSecrets[msg.sender] != 0) revert StoreAlreadyRegistered();
        if (_storeSecret == 0) revert InvalidValue();  // ✅ Now properly declared
        
        storeSecrets[msg.sender] = _storeSecret;
        emit StoreSecretSet(msg.sender);
    }
    
    /**
     * @dev Register a package for pickup (called by seller/platform)
     */
    function registerPackage(
        bytes32 _packageId,
        uint256 _buyerCommitment,
        uint256 _sellerCommitment,
        address _storeAddress,
        uint256 _itemPrice,
        uint256 _shippingFee,
        uint256 _minAgeRequired
    ) external payable {
        if (packages[_packageId].packageId != bytes32(0)) revert PackageAlreadyExists();
        if (!authorizedStores[_storeAddress]) revert StoreNotAuthorized();
        if (_minAgeRequired != 0 && _minAgeRequired != 18) revert InvalidAgeRequirement();
        if (_itemPrice < MIN_PACKAGE_VALUE) revert InsufficientValue();
        if (_buyerCommitment == 0 || _sellerCommitment == 0) revert InvalidInput();  // ✅ Now properly declared
        
        uint256 totalValue = _itemPrice + _shippingFee;
        if (msg.value < totalValue) revert InsufficientValue();
        
        uint256 expiryTime = block.timestamp + (PICKUP_VALIDITY_DAYS * 1 days);
        
        packages[_packageId] = Package({
            packageId: _packageId,
            buyerCommitment: _buyerCommitment,
            sellerCommitment: _sellerCommitment,
            storeAddress: _storeAddress,
            itemPrice: _itemPrice,
            shippingFee: _shippingFee,
            minAgeRequired: _minAgeRequired,
            isPickedUp: false,
            registeredAt: block.timestamp,
            expiryTime: expiryTime
        });
        
        emit PackageRegistered(_packageId, _buyerCommitment, _sellerCommitment, _storeAddress);
    }
    
    /**
     * @dev Generate store commitment (Step 1 of pickup process)
     */
    function generateStoreCommitment(bytes32 _packageId) external onlyAuthorizedStore returns (uint256) {
        Package storage pkg = packages[_packageId];
        if (pkg.packageId == bytes32(0)) revert PackageNotFound();
        if (pkg.storeAddress != msg.sender) revert WrongStore();
        if (pkg.isPickedUp) revert PackageAlreadyPickedUp();
        if (block.timestamp > pkg.expiryTime) revert PackageExpired();
        if (storeCommitments[_packageId].commitment != 0) revert StoreCommitmentExists();
        
        uint256 storeSecret = storeSecrets[msg.sender];
        if (storeSecret == 0) revert StoreNotAuthorized();
        
        // Generate store commitment: hash(sellerCommitment, storeSecret, packageId)
        uint256 storeCommitment = uint256(keccak256(abi.encodePacked(
            pkg.sellerCommitment,
            storeSecret,
            _packageId
        )));
        
        storeCommitments[_packageId] = StoreCommitment({
            commitment: storeCommitment,
            storeAddress: msg.sender,
            packageId: _packageId,
            generatedAt: block.timestamp,
            used: false
        });
        
        emit StoreCommitmentGenerated(_packageId, storeCommitment, msg.sender);
        return storeCommitment;
    }
    
    /**
     * @dev Execute package pickup with ZK proof verification (Step 2)
     */
    function pickupPackage(
        bytes32 _packageId,
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[5] memory _publicSignals
    ) external {
        Package storage pkg = packages[_packageId];
        StoreCommitment storage storeComm = storeCommitments[_packageId];
        
        // Validation checks
        if (pkg.packageId == bytes32(0)) revert PackageNotFound();
        if (pkg.isPickedUp) revert PackageAlreadyPickedUp();
        if (block.timestamp > pkg.expiryTime) revert PackageExpired();
        if (storeComm.commitment == 0) revert StoreCommitmentNotFound();
        if (storeComm.used) revert StoreCommitmentExists();
        if (usedNullifiers[_publicSignals[1]]) revert NullifierAlreadyUsed();
        
        // Verify public signals match package data
        if (_publicSignals[2] != 1) revert AgeVerificationFailed(); // age_verified must be 1
        if (_publicSignals[3] != uint256(_packageId)) revert PublicSignalMismatch();
        if (_publicSignals[4] != pkg.minAgeRequired) revert PublicSignalMismatch();
        
        // Prepare public inputs for ZK verification
        // [buyer_commitment, seller_commitment, store_commitment, package_id, min_age_required]
        uint[5] memory publicInputs = [
            pkg.buyerCommitment,
            pkg.sellerCommitment, 
            storeComm.commitment,
            uint256(_packageId),
            pkg.minAgeRequired
        ];
        
        // Verify ZK proof
        bool proofValid = verifier.verifyProof(_pA, _pB, _pC, publicInputs);
        if (!proofValid) revert InvalidProof();
        
        // Mark as completed
        pkg.isPickedUp = true;
        storeComm.used = true;
        usedNullifiers[_publicSignals[1]] = true;  // Mark nullifier as used
        
        // Transfer funds to store (simplified - in production, implement proper fee distribution)
        uint256 totalAmount = pkg.itemPrice + pkg.shippingFee;
        payable(pkg.storeAddress).transfer(totalAmount);
        
        emit PackagePickedUp(
            _packageId,
            _publicSignals[1], // nullifier
            _publicSignals[0], // group_signature
            pkg.storeAddress
        );
    }
    
    /**
     * @dev Get package details
     */
    function getPackageDetails(bytes32 _packageId) external view returns (Package memory) {
        return packages[_packageId];
    }
    
    /**
     * @dev Get store commitment details
     */
    function getStoreCommitmentDetails(bytes32 _packageId) external view returns (StoreCommitment memory) {
        return storeCommitments[_packageId];
    }
    
    /**
     * @dev Check if package can be picked up
     */
    function canPickupPackage(bytes32 _packageId) external view returns (bool) {
        Package memory pkg = packages[_packageId];
        return pkg.packageId != bytes32(0) &&
               !pkg.isPickedUp &&
               block.timestamp <= pkg.expiryTime &&
               storeCommitments[_packageId].commitment != 0;
    }
    
    /**
     * @dev Check if nullifier has been used
     */
    function isNullifierUsed(uint256 _nullifier) external view returns (bool) {
        return usedNullifiers[_nullifier];
    }
    
    /**
     * @dev Check if store is authorized and has secret set
     */
    function isStoreReady(address _store) external view returns (bool) {
        return authorizedStores[_store] && storeSecrets[_store] != 0;
    }
}